#!/bin/bash

# GitHub Copilot Usage Data Tool
# Fetches and displays your Copilot usage statistics from GitHub API

set -e

# Configuration
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/copilot-usage"
TOKEN_FILE="$CONFIG_DIR/github_token"
API_VERSION="2022-11-28"
GITHUB_API="https://api.github.com"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Helper functions
print_header() {
    echo -e "${BOLD}${BLUE}$1${NC}"
}

print_success() {
    echo -e "${GREEN}✓ $1${NC}"
}

print_error() {
    echo -e "${RED}✗ $1${NC}" >&2
}

print_info() {
    echo -e "${YELLOW}ℹ $1${NC}"
}

# Ensure config directory exists
ensure_config_dir() {
    mkdir -p "$CONFIG_DIR"
}

# Validate GitHub token by making a test API call
validate_token() {
    local token=$1
    
    # Test with a simple API call to /user endpoint
    local response=$(curl -s -w "\n%{http_code}" \
        -H "Accept: application/vnd.github+json" \
        -H "Authorization: Bearer $token" \
        -H "X-GitHub-Api-Version: $API_VERSION" \
        "$GITHUB_API/user")
    
    local http_code=$(echo "$response" | tail -n1)
    
    if [[ $http_code == 200 ]]; then
        return 0
    else
        local error_msg=$(echo "$response" | sed '$d' | jq -r '.message // empty' 2>/dev/null)
        print_error "Token validation failed: $error_msg"
        return 1
    fi
}

# Get or create GitHub token
get_github_token() {
    local token=""
    local max_attempts=3
    local attempt=0
    
    if [[ -f "$TOKEN_FILE" ]]; then
        token=$(cat "$TOKEN_FILE")
        # Validate existing token
        if validate_token "$token"; then
            echo "$token"
            return 0
        else
            # Existing token is invalid, prompt for new one
            print_info "Existing token is invalid. Please provide a new one."
            rm -f "$TOKEN_FILE"
        fi
    fi

    print_info "GitHub token not found. Setting up authentication..."
    echo ""
    echo "To get your token:"
    echo "1. Go to https://github.com/settings/tokens"
    echo "2. Click 'Generate new token (classic)' or create a fine-grained token"
    echo "3. Grant 'Plan' user permissions (read-only)"
    echo "4. Copy the token and paste it below"
    echo ""

    # Retry loop for token entry
    while [[ $attempt -lt $max_attempts ]]; do
        attempt=$((attempt + 1))
        read -sp "Enter your GitHub token: " token
        echo ""

        if [[ -z "$token" ]]; then
            print_error "Token cannot be empty"
            if [[ $attempt -lt $max_attempts ]]; then
                echo "Attempt $attempt/$max_attempts. Try again:"
            fi
            continue
        fi

        # Validate token format and access
        if validate_token "$token"; then
            echo "$token" > "$TOKEN_FILE"
            chmod 600 "$TOKEN_FILE"
            print_success "Token validated and saved to $TOKEN_FILE"
            echo "$token"
            return 0
        else
            if [[ $attempt -lt $max_attempts ]]; then
                print_info "Token validation failed. Please check:"
                echo "  - Token hasn't expired"
                echo "  - Token has 'Plan' (read) or 'user' permissions"
                echo "  - Token was copied completely without extra spaces"
                echo ""
                echo "Attempt $attempt/$max_attempts. Try again:"
            fi
        fi
    done

    print_error "Failed to authenticate after $max_attempts attempts"
    return 1
}

# Fetch data from GitHub API
fetch_api() {
    local endpoint=$1
    local token=$2

    response=$(curl -s -w "\n%{http_code}" \
        -H "Accept: application/vnd.github+json" \
        -H "Authorization: Bearer $token" \
        -H "X-GitHub-Api-Version: $API_VERSION" \
        "$GITHUB_API$endpoint")

    # Extract status code (last line) and body (everything else)
    http_code=$(echo "$response" | tail -n1)
    body=$(echo "$response" | sed '$d')

    if [[ $http_code != 200 ]]; then
        local error_msg=$(echo "$body" | jq -r '.message // empty' 2>/dev/null)
        if [[ -z "$error_msg" ]]; then
            error_msg=$(echo "$body" | grep -o '"message":"[^"]*"' | cut -d'"' -f4)
        fi
        print_error "API Error ($http_code): $error_msg"
        return 1
    fi

    echo "$body"
}


get_current_period() {
    local year=$(date +%Y)
    local month=$(date +%m)
    echo "?year=$year&month=$month"
}

# Fetch premium request usage (Copilot)
get_premium_request_usage() {
    local username=$1
    local token=$2
    local period=$3

    print_header "Copilot Premium Requests"
    
    data=$(fetch_api "/users/$username/settings/billing/premium_request/usage$period" "$token")
    
    if [[ -z "$data" ]]; then
        print_info "No premium request usage data available"
        return 0
    fi

    # Check if we have usage items
    if ! grep -q '"model"' <<< "$data"; then
        print_info "No premium request usage data available"
        return 0
    fi

    # Extract models and their gross quantities using grep
    local models=$(echo "$data" | grep -oP '"model":\s*"\K[^"]*')
    local quantities=$(echo "$data" | grep -oP '"grossQuantity":\s*\K[0-9.]+')
    local costs_gross=$(echo "$data" | grep -oP '"grossAmount":\s*\K[0-9.]+')
    local costs_net=$(echo "$data" | grep -oP '"netAmount":\s*\K[0-9.]+')
    
    # Convert to arrays
    mapfile -t models_array <<< "$models"
    mapfile -t quantities_array <<< "$quantities"
    mapfile -t costs_gross_array <<< "$costs_gross"
    mapfile -t costs_net_array <<< "$costs_net"
    
    # Check if we have any data
    if [[ ${#models_array[@]} -eq 0 ]]; then
        print_info "No premium request usage data available"
        return 0
    fi
    
    # Calculate totals
    local total_requests=0
    local total_cost=0
    local total_gross=0
    
    for i in "${!models_array[@]}"; do
        quantity=${quantities_array[$i]}
        cost_gross=${costs_gross_array[$i]}
        cost_net=${costs_net_array[$i]}
        
        if (( $(echo "$quantity > 0" | bc -l 2>/dev/null || echo 0) )); then
            total_requests=$(echo "$total_requests + $quantity" | bc -l 2>/dev/null)
            total_cost=$(echo "$total_cost + $cost_net" | bc -l 2>/dev/null)
            total_gross=$(echo "$total_gross + $cost_gross" | bc -l 2>/dev/null)
        fi
    done
    
    # Clean up numbers
    total_requests=$(echo "$total_requests" | bc -l 2>/dev/null)
    total_cost=$(echo "$total_cost" | bc -l 2>/dev/null | xargs printf '%.2f' 2>/dev/null)
    total_gross=$(echo "$total_gross" | bc -l 2>/dev/null | xargs printf '%.2f' 2>/dev/null)
    
    # Round total requests for display
    total_requests_display=$(echo "$total_requests" | xargs printf '%.0f' 2>/dev/null)

    # Display total requests
    echo ""
    echo -e "${BOLD}Total Requests: ${total_requests_display}${NC}"
    
    # Compare with Pro plan limit (300 requests)
    local pro_plan_limit=300
    if (( $(echo "$total_requests > $pro_plan_limit" | bc -l 2>/dev/null || echo 0) )); then
        local overage=$(echo "$total_requests - $pro_plan_limit" | bc -l 2>/dev/null | xargs printf '%.0f' 2>/dev/null)
        echo -e "${YELLOW}[!] Exceeded Pro plan limit by $overage requests${NC}"
    else
        local remaining=$(echo "$pro_plan_limit - $total_requests" | bc -l 2>/dev/null | xargs printf '%.0f' 2>/dev/null)
        echo -e "${GREEN}[✓] Within Pro plan limit ($remaining requests remaining)${NC}"
    fi

    echo ""
    
    # Display per-model breakdown
    echo -e "${BOLD}Requests by Model:${NC}"
    for i in "${!models_array[@]}"; do
        model=${models_array[$i]}
        quantity=${quantities_array[$i]}
        if (( $(echo "$quantity > 0" | bc -l 2>/dev/null || echo 0) )); then
            # Clean up the quantity display
            clean_qty=$(echo "$quantity" | sed 's/\.0*$//')
            echo "  $model: $clean_qty requests"
        fi
    done | sort
    
    echo ""
    
    # Display cost info
    if (( $(echo "$total_cost > 0" | bc -l 2>/dev/null || echo 0) )); then
        echo -e "${BOLD}Total Cost: \$${total_cost}${NC}"
        discount=$(echo "$total_gross - $total_cost" | bc -l 2>/dev/null | xargs printf '%.2f' 2>/dev/null)
        if (( $(echo "$discount > 0" | bc -l 2>/dev/null || echo 0) )); then
            print_info "Discount applied: \$${discount}"
        fi
    else
        echo -e "${GREEN}[✓] All requests covered by Pro plan (\$$total_gross value of usage)${NC}"
    fi
    echo ""
}

# Main execution
main() {
    local username=${1:-}
    local reset_token=${2:-}

    # Handle help
    if [[ "$username" == "-h" ]] || [[ "$username" == "--help" ]]; then
        echo "GitHub Copilot Usage Data Tool"
        echo ""
        echo "Usage: copilot-usage [username] [options]"
        echo ""
        echo "Options:"
        echo "  -h, --help          Show this help message"
        echo "  --reset-token       Reset stored GitHub token"
        echo "  [username]          GitHub username (defaults to current user)"
        echo ""
        echo "Examples:"
        echo "  copilot-usage                    # Use default user from git config"
        echo "  copilot-usage octocat            # Get usage for specific user"
        echo "  copilot-usage --reset-token      # Reset stored token"
        return 0
    fi

    # Handle token reset
    if [[ "$username" == "--reset-token" ]]; then
        ensure_config_dir
        rm -f "$TOKEN_FILE"
        print_success "Token cleared. A new token will be requested on next run."
        return 0
    fi

    # Ensure config directory exists
    ensure_config_dir

    # Get or prompt for token
    token=$(get_github_token) || return 1

    # Get username if not provided
    if [[ -z "$username" ]]; then
        # Try to get from git config
        username=$(git config user.name 2>/dev/null | tr ' ' '-' | tr '[:upper:]' '[:lower:]')
        if [[ -z "$username" ]]; then
            read -p "Enter your GitHub username: " username
        fi
    fi

    if [[ -z "$username" ]]; then
        print_error "Username is required"
        return 1
    fi

    echo ""
    print_header "Fetching Copilot Usage Data for: $username"
    echo ""

    # Get current month period
    period=$(get_current_period)

    # Fetch usage data
    get_premium_request_usage "$username" "$token" "$period"
}

# Run main function
main "$@"
